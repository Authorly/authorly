require 'sinatra'
require 'sinatra/cookies'
require 'json'
require 'active_record'
require 'resque'
require 'logger'
require 'kmts'

ENV['RACK_ENV'] ||= 'production'

configure do
  log_file = File.open(File.join(File.dirname(__FILE__), '..', 'log', ENV['RACK_ENV'] + '.log'), 'a+')
  log_file.sync = true if ENV['RACK_ENV'] == 'development'
  logger = Logger.new(log_file)
  logger.level = Logger::DEBUG
  set :logger, logger
end

def logger; settings.logger; end

config = YAML::load(ERB.new(IO.read(File.join(File.dirname(__FILE__), '..', 'db', 'config.yml'))).result)[ENV['RACK_ENV']].symbolize_keys
ActiveRecord::Base.establish_connection(config)

resque_config = YAML::load(ERB.new(IO.read(File.join(File.dirname(__FILE__), '..', 'db', 'resque.yml'))).result)[ENV['RACK_ENV']]
Resque.redis = resque_config

kiss_metrics_config = YAML::load(ERB.new(IO.read(File.join(File.dirname(__FILE__), '..', 'db', 'kissmetrics.yml'))).result)[ENV['RACK_ENV']]
KMTS.init(kiss_metrics_config, :log_dir => File.join(File.dirname(__FILE__), '..', 'log'))

class MailerQueue
  @queue = :mailer
end

class User < ActiveRecord::Base
  has_secure_password

  validates_format_of :email, :with => /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i
  validates_uniqueness_of :email, :case_sensitive => false, :message => 'is in use.'
  validates_presence_of :email

  before_create { generate_token(:confirmation_token) }
  before_create { generate_token(:auth_token) }

  def save_with_password
    pass = SecureRandom.base64(32).gsub(/[=+$\/]/, '')[0..8]
    self.password = pass
    self.password_confirmation = pass
    self.accepted_terms = true
    save
  end

  def generate_token(column)
    self[column] = unique_token_for(column)
  end

  def unique_token_for(column)
    begin
      token = SecureRandom.urlsafe_base64
    end while User.exists?(column => token)
    token
  end
end

set :cookie_options, :expires => Time.now + 365 * 24 * 60 * 60 # 1 year from now

get '/' do
  logger.info "params: #{params.inspect}"

  km_id = cookies[:email].nil? ? cookies[:km_id] : cookies[:email]
  logger.info km_id
  if km_id.nil? || km_id.empty?
    km_id = User.new.unique_token_for(:kissmetrics_identifier)
    cookies[:km_id] = km_id
  end
  KMTS.record(km_id, 'Visited Homepage')

  erb :index
end

post '/users.json' do
  content_type :json
  logger.info "params: #{params.inspect}"

  # Existence of a user is checked to handle the case
  # when a person tries to sign up with two different
  # emails in same session.
  #
  # If the user tries to sign up again in the same
  # session, we assume that it is a different person.
  # Otherwise same kissmetrics_identifier will be
  # assigned to this new user. And it will result in
  # we tracking events generated by two different people
  # on behalf of the original person.
  km_id = cookies[:km_id]
  if km_id.nil? || km_id.empty? || User.exists?(:kissmetrics_identifier => km_id)
    km_id = User.new.unique_token_for(:kissmetrics_identifier)
    cookies[:km_id] = km_id
  end

  u = User.new(params['user'].merge(:kissmetrics_identifier => km_id))
  if u.save_with_password
    resp = { :name => u.name, :email => u.email, :id => u.id }
    cookies[:email] = u.email
    Resque.enqueue(MailerQueue, 'UserMailer', 'email_confirmation', u.id)
    KMTS.alias(u.email, km_id)
    KMTS.record(u.email, 'Signed Up')
  else
    resp = u.errors.messages
    # Use this flag in XHR request for error handling.
    resp[:error] = 'oops'
  end

  status 200
  resp.to_json
end

post '/kmetrics.json' do
  content_type :json
  logger.info "params: #{params.inspect}"

  km_id = cookies[:email].nil? ? cookies[:km_id] : cookies[:email]
  logger.info km_id
  if km_id.nil? || km_id.empty?
    km_id = User.new.unique_token_for(:kissmetrics_identifier)
    cookies[:km_id] = km_id
  end
  KMTS.record(km_id, params['km_event']['name'])
  resp = { :status => 'OK' }

  status 200
  resp.to_json
end

post '/unbounce.json' do
  content_type :json
  logger.info "params: #{params.inspect}"

  user_data = JSON.parse(params['data.json'])
  u = User.new(:name => user_data['name'].first, :email => user_data['email'].first)
  if u.save_with_password
    resp = { :name => u.name, :email => u.email, :id => u.id }
    Resque.enqueue(MailerQueue, 'UserMailer', 'email_confirmation', u.id)
    KMTS.record(u.email, "Signed Up", :referrer => params['page_url'], :page_name => params['page_name'])
  else
    resp = u.errors.messages
    # Use this flag in XHR request for error handling.
    resp[:error] = 'oops'
  end

  status 200
  resp.to_json
end
